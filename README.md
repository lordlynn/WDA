# Wireless Data Acquisition - Wireless, Low-Cost, and Portable EMG System


# Abstract
The growing interest in electromyography (EMG) technology outside of its traditional clinical applications has led to a new demand for low-cost EMG systems that facilitate the recording of complex movements.

Here, a low-cost, wireless, and portable EMG system was developed using off-the-shelf hardware components. This wireless system transmits EMG data while allowing the subjects to perform movements in a more natural and unencumbered manner. To validate the system, two experiments were conducted which aimed to recreate the results of previous research that used a wired EMG platform, which is the current standard. First, a balance study was conducted with 3 stability conditions. These data were analyzed using magnitude squared coherence (MSC) with neural band averaging, and the results were benchmarked against the current standard. Second, a fatigue study was conducted to verify the fidelity of EMG data on all four sensors. The fatigue results were analyzed using mean absolute value (MAV) for amplitude analysis and median frequency (MDF) for spectral analysis. 
The MSC and neural band averaging analysis agreed with the results from previous research. The general trends were recreated, especially when considering the unilateral muscle pairs, but the system did not reach statistical significance for bilateral muscle pairs due to the small sample size. Conversely, the amplitude and frequency analysis of the fatigue data agreed with previous research, confirming the fidelity of our EMG recordings with each of the four sensors.

Pilot results show promise, but further balance studies need to be performed to formalize the benchmarking. Additionally, the development of a custom PCB to more closely integrate the components would help reduce the footprint of the device and further facilitate studying complex movement. 


# Introduction
Surface electromyography (sEMG or simply EMG) is a technique that employs surface electrodes on the skin to detect and analyze the electrical activity generated by skeletal muscles.  EMG is used typically for understanding conditions such as muscle fatigue, denervation, reinnervation, muscle coordination, load sharing, spasticity, and muscle activation [1]. More recently, EMG has evolved beyond its traditional applications [1]. Analysis of these signals has the potential to offer insights into the intricate control exerted by the nervous system in order to modulate motor units and control muscles. Also in recent years, EMG technology has witnessed a remarkable expansion into diverse fields including but not limited to obstetrics, occupational medicine, neuro-rehabilitation, ergonomics, preventive medicine, research on aging, veterinary science, sports sciences, control of artificial limbs, robotics, and the development of human-machine interfaces [1]. This broadened scope has led to an increase in the number of potential users, reflecting the growing importance of EMG.

Since EMG measures very small voltages under the surface of the skin, the required hardware can often be complex and expensive. A variety of EMG hardware architectures exist, however, the majority of EMG acquisition systems are fully wired. Fully wired systems employ a wired connection between proprietary hardware and a computer which acts as a host device to receive the data. Connected to the proprietary hardware are proprietary sensors. This clunky interface from sensor to computer is one drawback of wired systems that can make it hard to have mobile EMG systems. Another downside is that wired configurations are also more susceptible to environmental noise such as power line interference. Lastly, wired systems will restrict the movement of subjects, oftentimes making the recording of complex movements impractical and unnatural [2].

Wireless systems, on the other hand, can make the recording of complex movements much easier since a system can be secured to a subject with no extraneous wires that can be tugged or tangled. Wireless systems similar to the one described in this paper transmit the data from the subject wirelessly, but may still use wired connections between the sensors and an embedded device that reports the data. Other systems may employ a more advanced version of wireless sensors, wherein each sensor can report its data wirelessly, thus no wires are used at all. Both versions of wireless systems are typically more expensive than their wired counterparts, with the second wireless option requiring the most investment [3].

The utility of the system would lie in non-traditional EMG applications such as sports sciences, control of artificial limbs, and human-machine interfaces. So, the system was designed to be wireless to support the capturing of complex human motion. For our purposes, wireless is defined as a system with no tethers between the subject and the recording hardware. Wires still connect the individual sensors to the microcontroller, but the microcontroller uses WiFi to report the EMG data to the core application running on a host computer. The system is also battery powered so no external power connections are needed. 

This system utilizes Myoware2.0 (Advancer Technologies, Raleigh NC) sensors for measuring the EMG signals, Teensy4.1 (PJRC, Sherwood OR) microcontrollers for recording the data, and the WizFi360 (WizNet, Seongnam, Kyonggi-do, South Korea) module for reporting the data over WiFi. The core application provides a way to modify sample frequency, length in seconds of trial, and the number of EMG channels to record. The core application also provides a way to save test data to .csv files for offline analysis. 

# System Design
### Block Diagram
The embedded block encapsulates the EMG sensors and wireless communications to highlight how the data makes its way from sensor to file. The computer block represents a Windows machine running the core application and a Message Queuing Telemetry Transport  (MQTT) broker in order to communicate with the embedded block. Note that the system was designed to support two embedded devices simultaneously, but can also function with only one.

![highLevelView_R3](https://github.com/user-attachments/assets/74c8a55e-8b73-4c0e-8715-9a470d2a1016)

### Embedded
The Teensy4.1 microcontroller was selected due to its active community of developers and performance. All Teensy microcontrollers are compatible with Arduino IDE (Arduino, Somerville, MA) so they provide an easy-to-use interface for programming. Teensy microcontrollers cost about the same as Arduinos but with disproportionally greater performance for the price.

The protocol for wireless communication was chosen to be MQTT due to its ease of use and large community of active users. Additionally, MQTT boasts a reduced footprint compared to other protocols such as HTTP, rendering it better suited for environments constrained by limited memory, bandwidth, and computational power [4].
The decision to use MQTT led to the selection of a second peripheral processor that added WiFi functionality to the Teensy4.1. A core requirement for this peripheral was that it supported MQTT by default. The WizFi360 evaluation board was selected since it supported MQTT by default with all Quality of Services available.


This image shows a high level view of the embedded hardware. 
![wiringDiagram_R2](https://github.com/user-attachments/assets/7826feef-a1a5-4055-ab6d-d2203ee2dac8)

The embedded application utilizes the WizFi360 board to connect to WiFi and then connect to the broker. If the connection is successful, then the system proceeds to send a small message used to establish a connection with the core application. The message contains the current RTC time held by the system. When a connection is successfully established, the core application returns the message, signaling that it is ready. At this point, the system proceeds to wait for the test configuration.

When the user enters the desired sampling frequency, test time, and number of channels, the start button can be pressed in the core application. This sends a configuration message to all connected sensors. When the configuration message is received, a start time relative to the EMG device’s RTC is read and the program blocks until the RTC time matches that of the configuration message. This blocking and waiting to start the data capture allows for multiple connected devices to begin sampling at the same time. Interrupts were then used to sample the data at consistent intervals while keeping the CPU free to work on transmitting the data. 

Once the test time has expired, the interrupts are disabled, and sampling ends. Data transmission continues until all of the data has been sent to the broker. Then the core application is pinged once again to restart the cycle. Sending ping messages on startup and after every test ensures that the core application is aware if a sensor is no longer responding. 

This image shows the program flow for the embedded devices. 
![MQTT_Teensy drawio](https://github.com/user-attachments/assets/81dd9baf-babd-4622-8631-9584315e8ea1)

Outside of the normal program flow shown in the above figure is the RTC time synchronization. In order to synchronize the data capture of two EMG devices in time, a GPIO interrupt was used to trigger a simultaneous RTC reset. By connecting the RTC Synch port from multiple systems, a button can be used to cause a simultaneous interrupt for both devices. This interrupt was set to be triggered by the falling edge on the GPIO pin which has an internal pull-up resistor. This was done so that minimal hardware would be required for RTC synchronization. When the interrupt occurs the RTC time was reset to 0, effectively synchronizing multiple systems.

The time synchronization can then be tested using a function generator to apply the same waveform to the channel 1 input of both EMG devices The recorded waveforms can then be used to determine the time synchronization of the systems. To test the time synchronization, a 40 Hz squarewave was connected to the input of both systems; the resulting data is provided in the results section.

In order to preserve this time synchronization the Teensy4.1 RTCs are powered by coin cell batteries (CR2032) that can last for upwards of 40 days. So, time synchronization will not be required after every power cycle. 


### Core Application
The program flow of the core application begins with an initialization where a connection to the broker is established. After successfully connecting to the broker, and at the end of each data capture, the application pings the EMG devices to ensure they are connected. The application then waits for the user to enter their desired test configuration and begin the test. After sending the configuration message, the core application waits for the embedded device to send either “start” or “error”. If the device parses the configuration message successfully, “start” is returned and data capture is initiated. If the device fails to parse the configuration message, “error” is returned and the device waits for a new configuration.
	
When data is received it is plotted on the right side of the application window and simultaneously saved to a CSV file. The core application waits in this state until the embedded device sends the message “end”, signaling that the last of the data has been sent. At this point the data file is closed and the cycle repeats.


This image shows the program flow for the core application. 
![MQTT_PC drawio](https://github.com/user-attachments/assets/7bd7dd01-43f2-448c-b5da-25590c27eba5)

After data has been captured, custom analysis functions built into the embedded plots can be run to perform quick analysis. The core application provides a FFT, linear envelope functions, and five unimplemented custom functions. The custom functions are left to be implemented by end users and can take on a wide variety of use cases such as spectral analysis, electrocardiogram (ECG) removal, saving data to alternative formats, etc. 

The custom analysis functions can be accessed from within the project folder; there are five Python templates named func1.py - func5.py. The fft.py and env.py files may serve as examples for end users looking to implement their own analysis functions. The only requirements are that the functions must be written in Python and initiate execution from the predefined files. The template files will read and parse the sampling frequency, original parent figure title, and the parent figure data from the core application allowing the user to implement future signal processing algorithms in the template files.

# Shortened Bibliography
[1]	ALCAN, V., & ZİNNUROĞLU, M. (2023). Current developments in surface electromyography. Turkish Journal of Medical Sciences, 53(5), 1019–1031. https://doi.org/10.55730/1300-0144.5667 

[2]	Zhou, R., Luo, Q., Feng, X., & Li, C. (2017). Design of a wireless multi-channel surface EMG Signal Acquisition System. 2017 3rd IEEE International Conference on Computer and Communications (ICCC). https://doi.org/10.1109/compcomm.2017.8322556 

[3]	Bawa, A., & Banitsas, K. (2022). Design validation of a low-cost EMG sensor compared to a commercial-based system for measuring muscle activity and fatigue. Sensors, 22(15), 5799. https://doi.org/10.3390/s22155799

[4]	Darujati, Y. V., Saputra, L. K., Lukito, Y., & Guspara, W. A. (2023). Evaluation of HTTP and MQTT protocols in the design of telemetry data for embedded systems on smart wheelchairs. 2023 IEEE International Conference on Data and Software Engineering (ICoDSE). https://doi.org/10.1109/icodse59534.2023.10291260 
